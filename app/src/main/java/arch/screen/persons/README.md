### Описание экрана
* Список сущностей с возможностью обновить, но без пагинации
* Для концепта с несколькими view добавил создание элемента и фильтрацию списка, так же разделил view состояния экрана и view списка
* Переход на детальную информацию

# ВАЖНО
Если страшна мысль отказаться от презентеров то предлогаю думать в сторону отказа от интерфейсов ограничивающий количество view для презентера.

### Цели
* KISS
* Сохранение состояния
* Поддержка нескольких view, router или чего другого для одного функционального атома
* Не потерять возможность переиспользования кусков архитектуры
* более реактивный и функциональный подход к бизнес логике

### Об архитектуре
* Пример развивает концепт нескольких view классов на экран, так что функции bindUiWithStates и bindScreenWithFeatures могут показаться большими и не удобными. Но повторюсь это же было бы реализовано в презентере.

При класическом подходе
View1 - Presenter1
View2 - Presenter2
View3 - Presenter3

Есть проблема общения между презентерами. В моём случае если фиче нужны несколько view или state классов, то они просто передаются в неё аргументами.

* Презентер превратился в feature функции
* AttachView переехал частично в функции bindUiToState и частично в feature функции
* Отказался от полного проксирования Observable и Consumer через Connector/State/ViewModel

### Заметки
* Feature для создания и фильтрации не реализованы, но view и state есть
* Сохранение State не реализовано

### Опционально
* Добавил StateMachine взамен viewNotification и viewNotificationPair
* Добавил контейнеры для view и state классов, для более удобной записи функций